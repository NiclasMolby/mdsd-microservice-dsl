/*
 * generated by Xtext 2.16.0
 */
package dk.sdu.mdsd.micro_lang.validation

import com.google.inject.Inject
import dk.sdu.mdsd.micro_lang.MicroLangModelUtil
import dk.sdu.mdsd.micro_lang.microLang.Implements
import dk.sdu.mdsd.micro_lang.microLang.MicroLangPackage
import dk.sdu.mdsd.micro_lang.microLang.Microservice
import dk.sdu.mdsd.micro_lang.microLang.NormalPath
import dk.sdu.mdsd.micro_lang.microLang.Operation
import dk.sdu.mdsd.micro_lang.microLang.Parameter
import dk.sdu.mdsd.micro_lang.microLang.ParameterPath
import dk.sdu.mdsd.micro_lang.microLang.Return
import dk.sdu.mdsd.micro_lang.microLang.TypedParameter
import dk.sdu.mdsd.micro_lang.microLang.Uses
import dk.sdu.mdsd.micro_lang.microLang.impl.GatewayImpl
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check

import static org.eclipse.emf.ecore.util.EcoreUtil.UsageCrossReferencer.find

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MicroLangValidator extends AbstractMicroLangValidator {
	
	protected static val ISSUE_CODE_PREFIX = 'dk.sdu.mdsd.micro_lang.'
	
	public static val USES_SELF = ISSUE_CODE_PREFIX + 'UsesSelf'
	
	public static val IMPLEMENT_CYCLE = ISSUE_CODE_PREFIX + 'ImplementCycle'
	
	public static val UNREACHABLE_CODE = ISSUE_CODE_PREFIX + 'UnreachableCode'
	
	public static val INVALID_AMOUNT_ARGS = ISSUE_CODE_PREFIX + 'InvalidAmountArgs'
	
	public static val PARAMETER_NOT_USED = ISSUE_CODE_PREFIX + 'ParameterNotUsed'
	
	public static val INVALID_MICROSERVICE_NAME = ISSUE_CODE_PREFIX + 'InvalidMicroserviceName'
	
	public static val INVALID_ENDPOINT_PATH_NAME = ISSUE_CODE_PREFIX + 'InvalidEndpointPathName'
	
	public static val INVALID_ATTRIBUTE_ON_REQUIRE = ISSUE_CODE_PREFIX + 'InvalidAttribute'
	
	public static val NO_ATTRIBUTE_ON_PARAMETER_PATH_REQUIRE = ISSUE_CODE_PREFIX + 'NoAttributeOnRequire'
	
	public static val GIVEN_ON_NON_GATEWAY_ELEMENT = ISSUE_CODE_PREFIX + 'GivenOnNonGatewayElement'
	
	val epackage = MicroLangPackage.eINSTANCE
	
	@Inject
	extension MicroLangModelUtil
	
	@Check
	def checkGivenOnElement(Operation operation) {
		if(operation.containsGiven && !(operation.eContainer.eContainer instanceof GatewayImpl)) {
			error("The 'given' keyword can only be used on Gateways", 
			operation, 
			epackage.operation_Statements, 
			GIVEN_ON_NON_GATEWAY_ELEMENT)
		}
	}
	
	@Check
	def checkSelfNotInUses(Uses uses) {
		val container = uses.eContainer as Microservice
		if (uses.target === container) {
			error('Microservice "' + container.name + '" references itself', 
				uses, 
				epackage.uses_Target, 
				USES_SELF, 
				uses.target.name)
		}
	}
	
	@Check
	def void checkNoCycleInImplements(Implements implement) {
		val visited = newHashSet(implement.eContainer)
		implement.checkNoCycleInImplements(visited)
	}
	
	def private void checkNoCycleInImplements(Implements implement, Set<EObject> visited) {
		if (visited.contains(implement.target)) {
			error('Cycle in hierarchy of template "' + implement.target.name + '"', 
				implement, 
				epackage.implements_Target, 
				IMPLEMENT_CYCLE, 
				implement.target.name)
			return
		}
		visited.add(implement.target)
		implement.target.implements.forEach[checkNoCycleInImplements(visited)]
	}
	
	@Check
	def checkUnreachableCode(Operation operation) {
		val statements = operation.statements
		for (i : 0 ..< statements.size - 1) {
			if (statements.get(i) instanceof Return) {
				error('Unreachable code', 
					statements.get(i + 1), 
					null, 
					UNREACHABLE_CODE)
				return
			}
		}
	}
	
	@Check
	def checkImplementCorrectAmountArgs(Implements implement) {
		val template = implement.target
		val expected = template.parameters.size
		val actual = implement.arguments.size
		if (actual != expected) {
			error('Invalid number of arguments. Expected ' + expected + ' but received ' + actual, 
					implement, 
					null, 
					INVALID_AMOUNT_ARGS)
		}
	}
	
	@Check
	def checkParameterIsUsed(Parameter parameter) {
		val references = find(parameter, parameter.eContainer)
		if (references.empty) {
			warning('The parameter "' + parameter.name + '" is not used', 
				parameter, 
				null, 
				PARAMETER_NOT_USED)
		}
	}
	
	@Check
	def checkMicroserviceNameIsUpperCase(Microservice microservice) {
		val name = microservice.name
		if (name != name.toUpperCase) {
			warning('Microservice name should be written in upper case', 
				microservice, 
				epackage.element_Name, 
				INVALID_MICROSERVICE_NAME, 
				name)
		}
	}
	
	@Check
	def checkNormalPathIsLowerCase(NormalPath path) {
		val name = path.name
		if (name === null) {
			return
		}
		if(name != name.toLowerCase) {
			warning('Endpoint path should be written in lower case', 
					path,
					epackage.normalPath_Name,  
					INVALID_ENDPOINT_PATH_NAME, 
					name)
		}
	}
	
	val allowedRequireAttributes = #{
		"string" -> #["length"],
		"int" -> #["value"],
		"double" -> #['value'],
		"bool" -> #[]
	}
	
	@Check
	def checkAttributeOnRequireIsValid(TypedParameter param) {
		val type = param.type.name
		val logic = param.require.logic
		if (logic === null) {
			return
		}
		
		val attributes = logic.attributes
		val allowedAttributes = this.allowedRequireAttributes.get(type)
		
		val illegalAttributes = attributes.filter[attribute | !allowedAttributes.contains(attribute)].toSet
		
		if (!illegalAttributes.empty) {
			val attributeString = if(illegalAttributes.length > 1) "Attributes" else "Attribute"
			error(attributeString + ' "' + illegalAttributes.printSet + '" can not be used on type "' + type + '"',
				param,
				epackage.typedParameter_Require,
				INVALID_ATTRIBUTE_ON_REQUIRE
			)
		}
	}
	
	@Check
	def checkParameterPathRequireContainsAttributes(ParameterPath param) {
		val logic = param.parameter.require.logic
		if (logic === null) {
			warning('The "require" keyword is not necessary on parameters in the path without logic conditions',
				param.parameter,
				epackage.typedParameter_Require,
				INVALID_ATTRIBUTE_ON_REQUIRE
			)
		}
	}
}

