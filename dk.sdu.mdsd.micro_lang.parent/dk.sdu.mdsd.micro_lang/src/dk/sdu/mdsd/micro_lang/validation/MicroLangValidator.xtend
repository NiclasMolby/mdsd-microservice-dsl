/*
 * generated by Xtext 2.16.0
 */
package dk.sdu.mdsd.micro_lang.validation

import com.google.inject.Inject
import dk.sdu.mdsd.micro_lang.MicroLangModelUtil
import dk.sdu.mdsd.micro_lang.microLang.Implements
import dk.sdu.mdsd.micro_lang.microLang.MicroLangPackage
import dk.sdu.mdsd.micro_lang.microLang.Microservice
import dk.sdu.mdsd.micro_lang.microLang.NormalPath
import dk.sdu.mdsd.micro_lang.microLang.Operation
import dk.sdu.mdsd.micro_lang.microLang.Parameter
import dk.sdu.mdsd.micro_lang.microLang.ParameterPath
import dk.sdu.mdsd.micro_lang.microLang.Return
import dk.sdu.mdsd.micro_lang.microLang.TypedParameter
import dk.sdu.mdsd.micro_lang.microLang.Uses
import dk.sdu.mdsd.micro_lang.microLang.impl.GatewayImpl
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check

import static org.eclipse.emf.ecore.util.EcoreUtil.UsageCrossReferencer.find
import dk.sdu.mdsd.micro_lang.microLang.GatewayCondition
import dk.sdu.mdsd.micro_lang.microLang.Given

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MicroLangValidator extends AbstractMicroLangValidator {
	
	protected static val ISSUE_CODE_PREFIX = 'dk.sdu.mdsd.micro_lang.'
	
	public static val USES_SELF = ISSUE_CODE_PREFIX + 'UsesSelf'
	
	public static val IMPLEMENT_CYCLE = ISSUE_CODE_PREFIX + 'ImplementCycle'
	
	public static val UNREACHABLE_CODE = ISSUE_CODE_PREFIX + 'UnreachableCode'
	
	public static val INVALID_AMOUNT_ARGS = ISSUE_CODE_PREFIX + 'InvalidAmountArgs'
	
	public static val PARAMETER_NOT_USED = ISSUE_CODE_PREFIX + 'ParameterNotUsed'
	
	public static val INVALID_MICROSERVICE_NAME = ISSUE_CODE_PREFIX + 'InvalidMicroserviceName'
	
	public static val INVALID_ENDPOINT_PATH_NAME = ISSUE_CODE_PREFIX + 'InvalidEndpointPathName'
	
	public static val INVALID_ATTRIBUTE_ON_REQUIRE = ISSUE_CODE_PREFIX + 'InvalidAttribute'
	
	public static val NO_ATTRIBUTE_ON_PARAMETER_PATH_REQUIRE = ISSUE_CODE_PREFIX + 'NoAttributeOnRequire'
	
	public static val GIVEN_ON_NON_GATEWAY_ELEMENT = ISSUE_CODE_PREFIX + 'GivenOnNonGatewayElement'
	
	public static val GIVEN_CONDITION_NO_OPERATOR = ISSUE_CODE_PREFIX + 'GivenConditionNoOperator'
	
	public static val GIVEN_CONDITION_REFERENCE_NO_RETURN_TYPE = ISSUE_CODE_PREFIX + 'GivenConditionReferenceNoReturnType'
	
	public static val GIVEN_CONDITION_REFERENCE_NO_OPERATOR = ISSUE_CODE_PREFIX + 'GivenConditionReferenceNoOperator'
	
	public static val GIVEN_CONDITION_WRONG_OPERATOR = ISSUE_CODE_PREFIX + 'GivenConditionWrongOperator'
	
	public static val GIVEN_CONDITION_WRONG_OPERATOR_REFERENCE = ISSUE_CODE_PREFIX + 'GivenConditionWrongOperatorReference'
	
	public static val GIVEN_CONDITION_REFERED_METHOD_NOT_FOUND = ISSUE_CODE_PREFIX + 'GivenConditionReferedMethodNotFound'
	
	public static val GIVEN_CONDITION_REFERED_METHOD_NOT_GET = ISSUE_CODE_PREFIX + 'GivenConditionReferedMethodNotGET'
	
	public static val GIVEN_CONDITION_REQUIED_ARG_CANNOT_BE_PARSED = ISSUE_CODE_PREFIX + 'GivenConditionRequiredArgCannotBeParsed'
	
	val epackage = MicroLangPackage.eINSTANCE
	
	@Inject
	extension MicroLangModelUtil
	
	
	
	@Check
	def checkGivenMicroserviceReference(Given given) {
		val foundLeftEndpoint = given.left.resolveMethodReference(given.eContainer as Operation)
		val foundRightEndpoint = given.right.resolveMethodReference(given.eContainer as Operation)
		
		if (foundLeftEndpoint === null) {
			error("This endpoint cannot be found.",
				given,
				epackage.given_Left,
				GIVEN_CONDITION_REFERED_METHOD_NOT_FOUND)
		}
		
		if (foundRightEndpoint === null) {
			error("This endpoint cannot be found.",
				given,
				epackage.given_Right,
				GIVEN_CONDITION_REFERED_METHOD_NOT_FOUND)
		}
	}
	
	@Check
	def checkGivenRequireCannotBeParsedOn(Given given) {
		val foundLeftEndpoint = given.left.resolveMethodReference(given.eContainer as Operation)
		val foundRightEndpoint = given.right.resolveMethodReference(given.eContainer as Operation)
		
		val leftParams = foundLeftEndpoint.statements.filter(TypedParameter)
		val rightParams = foundRightEndpoint.statements.filter(TypedParameter)
		rightParams.forEach[rightParam |
			if (rightParam.require !== null) {
				if(!leftParams.exists[leftParam | rightParam.name == leftParam.name && rightParam.type.name == leftParam.type.name]) {
					error("The else endpoint contains a required parameter which cannot be found on this endpoint.",
						given,
						epackage.given_Left,
						GIVEN_CONDITION_REQUIED_ARG_CANNOT_BE_PARSED)
				}
				if(leftParams.exists[leftParam | rightParam.name == leftParam.name && rightParam.type.name == leftParam.type.name && leftParam.require === null]) {
					error("The else endpoint contains a required parameter which is not required on this endpoint.",
						given,
						epackage.given_Left,
						GIVEN_CONDITION_REQUIED_ARG_CANNOT_BE_PARSED)
				}
			}
		]
		
	}
	
	@Check
	def checkGivenConditionReferedMethodNotGet(GatewayCondition condition) {
		val microservice = condition.endpoint
		if (microservice !== null) {
			val reference = resolveMethodReference(microservice, "GET")
			if (reference === null) {
				error("This endpoint must be a GET method.",
					condition,
					epackage.gatewayCondition_Endpoint,
					GIVEN_CONDITION_REFERED_METHOD_NOT_GET)
			}	
		}
	}
	
	@Check
	def checkGivenConditionNoOperator(GatewayCondition condition) {
		if (condition.parameter !== null && condition.op === null && condition.parameter.type.name != "bool") {
			error("Must have a comparison condition unless type is boolean",
				condition,
				epackage.gatewayCondition_Parameter,
				GIVEN_CONDITION_NO_OPERATOR)
		}
	}
	
	@Check
	def checkGivenConditionNoReturnTypeMicroserviceEndpoint(GatewayCondition condition) {
		val microservice = condition.endpoint
		if (microservice !== null) {
			val reference = resolveMethodReference(microservice, "GET")
			val returnType = reference.statements.filter(Return)
			if (returnType.empty) {
				error("Microservice endpoint reference must have a return type",
					condition.eContainer,
					epackage.given_Condition,
					GIVEN_CONDITION_REFERENCE_NO_RETURN_TYPE)
			}
		}
	}
	
	@Check
	def checkGivenConditionEqualReturnTypes(Given given) {
		val foundLeftEndpoint = given.left.resolveMethodReference(given.eContainer as Operation)
		val foundRightEndpoint = given.right.resolveMethodReference(given.eContainer as Operation)
		
		val leftReturn = foundLeftEndpoint.statements.filter(Return)
		val rightReturn = foundRightEndpoint.statements.filter(Return)
		
		if (!leftReturn.empty) {
			if (rightReturn.empty) {
				error("This endpoint must have a return type, as the other endpoint does.",
					given,
					epackage.given_Right,
					GIVEN_CONDITION_REFERENCE_NO_RETURN_TYPE)
			} else {
				if (leftReturn.head.type.name != rightReturn.head.type.name) {
					error("This endpoint must have the same return type as the other endpoint.",
						given,
						epackage.given_Right,
						GIVEN_CONDITION_REFERENCE_NO_RETURN_TYPE)
				}
			}
			
		} else {
			if (!rightReturn.empty) {
				warning("This endpoints return value is not used.",
						given,
						epackage.given_Right,
						GIVEN_CONDITION_REFERENCE_NO_RETURN_TYPE)
			}
		}
	}
	
	@Check
	def checkGivenConditionNoOperatorMicroserviceEndpoint(GatewayCondition condition) {
		val microservice = condition.endpoint
		if (microservice !== null) {
			val reference = resolveMethodReference(microservice, "GET")
			val returnType = reference.statements.filter(Return)
			if (!returnType.empty) {
				if (condition.op === null && returnType.head.type.name != "bool") {
					error("Must have a comparison condition unless type is boolean",
						condition,
						epackage.gatewayCondition_Parameter,
						GIVEN_CONDITION_REFERENCE_NO_OPERATOR)
				}
			}
		}
	}
	
	@Check
	def checkGivenConditionWrongOperator(GatewayCondition condition) {
		if (condition.parameter !== null && condition.op !== null && condition.parameter.type.name == "string" && !condition.op.eq) {
			error("A string can only be compared using '='.",
				condition.eContainer,
				epackage.given_Condition,
				GIVEN_CONDITION_WRONG_OPERATOR)
		}
		if (condition.parameter !== null && condition.op !== null && condition.parameter.type.name == "bool") {
			error("A boolean should not be compared to anything, as it is already a condition.",
				condition.eContainer,
				epackage.given_Condition,
				GIVEN_CONDITION_WRONG_OPERATOR)
		}
	}
	
	@Check
	def checkGivenConditionWrongOperatorReference(GatewayCondition condition) {
		val microservice = condition.endpoint
		if (microservice !== null) {
			val reference = resolveMethodReference(microservice, "GET")
			val returnType = reference.statements.filter(Return)
			if (!returnType.empty) {
				if (condition.op !== null && returnType.head.type.name == "string" && !condition.op.eq) {
					error("A string can only be compared using '='.",
						condition.eContainer,
						epackage.given_Condition,
						GIVEN_CONDITION_WRONG_OPERATOR_REFERENCE)
				}
				if (condition.op !== null && returnType.head.type.name == "bool") {
					error("A boolean should not be compared to anything, as it is already a condition.",
						condition.eContainer,
						epackage.given_Condition,
						GIVEN_CONDITION_WRONG_OPERATOR_REFERENCE)
				}
			}
		}
	}
	
	@Check
	def checkGivenConditionWrongTypeComparison(GatewayCondition condition) {
		if (condition.parameter !== null && condition.op !== null && condition.parameter.type.name == "string" && condition.comparison.stringValue === null) {
			error("A string can only be compared to another string.",
				condition.eContainer,
				epackage.given_Condition,
				GIVEN_CONDITION_WRONG_OPERATOR)
		}
		
		if (condition.parameter !== null && condition.op !== null && condition.parameter.type.name == "int" && condition.comparison.stringValue !== null) {
			error("A int can only be compared to another int.",
				condition.eContainer,
				epackage.given_Condition,
				GIVEN_CONDITION_WRONG_OPERATOR)
		}
		
		if (condition.parameter !== null && condition.op !== null && condition.parameter.type.name == "double" && condition.comparison.stringValue !== null) {
			error("A double can only be compared to a int.",
				condition.eContainer,
				epackage.given_Condition,
				GIVEN_CONDITION_WRONG_OPERATOR)
		}
	}
	
	@Check
	def checkGivenConditionWrongTypeComparisonReference(GatewayCondition condition) {
		val microservice = condition.endpoint
		if (microservice !== null) {
			val reference = resolveMethodReference(microservice, "GET")
			val returnType = reference.statements.filter(Return)
			if (!returnType.empty) {
				if (condition.op !== null && returnType.head.type.name == "string" && condition.comparison.stringValue === null) {
					error("A string can only be compared to another string.",
						condition.eContainer,
						epackage.given_Condition,
						GIVEN_CONDITION_WRONG_OPERATOR_REFERENCE)
				}
				if (condition.op !== null && returnType.head.type.name == "int" && condition.comparison.stringValue !== null) {
					error("A int can only be compared to another int.",
						condition.eContainer,
						epackage.given_Condition,
						GIVEN_CONDITION_WRONG_OPERATOR_REFERENCE)
				}
				if (condition.op !== null && returnType.head.type.name == "double" && condition.comparison.stringValue !== null) {
					error("A double can only be compared to another int.",
						condition.eContainer,
						epackage.given_Condition,
						GIVEN_CONDITION_WRONG_OPERATOR_REFERENCE)
				}
			}
		}
	}
	
	@Check
	def checkGivenOnElement(Operation operation) {
		if(operation.containsGiven && !(operation.eContainer.eContainer instanceof GatewayImpl)) {
			error("The 'given' keyword can only be used on Gateways", 
			operation, 
			epackage.operation_Statements, 
			GIVEN_ON_NON_GATEWAY_ELEMENT)
		}
	}
	
	@Check
	def checkSelfNotInUses(Uses uses) {
		val container = uses.eContainer as Microservice
		if (uses.target === container) {
			error('Microservice "' + container.name + '" references itself', 
				uses, 
				epackage.uses_Target, 
				USES_SELF, 
				uses.target.name)
		}
	}
	
	@Check
	def void checkNoCycleInImplements(Implements implement) {
		val visited = newHashSet(implement.eContainer)
		implement.checkNoCycleInImplements(visited)
	}
	
	def private void checkNoCycleInImplements(Implements implement, Set<EObject> visited) {
		if (visited.contains(implement.target)) {
			error('Cycle in hierarchy of template "' + implement.target.name + '"', 
				implement, 
				epackage.implements_Target, 
				IMPLEMENT_CYCLE, 
				implement.target.name)
			return
		}
		visited.add(implement.target)
		implement.target.implements.forEach[checkNoCycleInImplements(visited)]
	}
	
	@Check
	def checkUnreachableCode(Operation operation) {
		val statements = operation.statements
		for (i : 0 ..< statements.size - 1) {
			if (statements.get(i) instanceof Return) {
				error('Unreachable code', 
					statements.get(i + 1), 
					null, 
					UNREACHABLE_CODE)
				return
			}
		}
	}
	
	@Check
	def checkImplementCorrectAmountArgs(Implements implement) {
		val template = implement.target
		val expected = template.parameters.size
		val actual = implement.arguments.size
		if (actual != expected) {
			error('Invalid number of arguments. Expected ' + expected + ' but received ' + actual, 
					implement, 
					null, 
					INVALID_AMOUNT_ARGS)
		}
	}
	
	@Check
	def checkParameterIsUsed(Parameter parameter) {
		val references = find(parameter, parameter.eContainer)
		if (references.empty) {
			warning('The parameter "' + parameter.name + '" is not used', 
				parameter, 
				null, 
				PARAMETER_NOT_USED)
		}
	}
	
	@Check
	def checkMicroserviceNameIsUpperCase(Microservice microservice) {
		val name = microservice.name
		if (name != name.toUpperCase) {
			warning('Microservice name should be written in upper case', 
				microservice, 
				epackage.element_Name, 
				INVALID_MICROSERVICE_NAME, 
				name)
		}
	}
	
	@Check
	def checkNormalPathIsLowerCase(NormalPath path) {
		val name = path.name
		if (name === null) {
			return
		}
		if(name != name.toLowerCase) {
			warning('Endpoint path should be written in lower case', 
					path,
					epackage.normalPath_Name,  
					INVALID_ENDPOINT_PATH_NAME, 
					name)
		}
	}
	
	val allowedRequireAttributes = #{
		"string" -> #["length"],
		"int" -> #["value"],
		"double" -> #['value'],
		"bool" -> #[]
	}
	
	@Check
	def checkAttributeOnRequireIsValid(TypedParameter param) {
		val type = param.type.name
		val logic = param.require.logic
		if (logic === null) {
			return
		}
		
		val attributes = logic.attributes
		val allowedAttributes = this.allowedRequireAttributes.get(type)
		
		val illegalAttributes = attributes.filter[attribute | !allowedAttributes.contains(attribute)].toSet
		
		if (!illegalAttributes.empty) {
			val attributeString = if(illegalAttributes.length > 1) "Attributes" else "Attribute"
			error(attributeString + ' "' + illegalAttributes.printSet + '" can not be used on type "' + type + '"',
				param,
				epackage.typedParameter_Require,
				INVALID_ATTRIBUTE_ON_REQUIRE
			)
		}
	}
	
	@Check
	def checkParameterPathRequireContainsAttributes(ParameterPath param) {
		val logic = param.parameter.require.logic
		if (logic === null) {
			warning('The "require" keyword is not necessary on parameters in the path without logic conditions',
				param.parameter,
				epackage.typedParameter_Require,
				INVALID_ATTRIBUTE_ON_REQUIRE
			)
		}
	}
}

